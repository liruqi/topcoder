* POJ 2559

2013.12.3

今天做这一题还是源于08年的北京交大的ACM区域赛。最近徐涵跟我说当时有一题我没做出来，一直超时。结束之后问旁边清华的队伍，说是单调队列。结果4年多过去了我还没弄明白单调队列为何物。徐涵记忆力好，就把这题的链接发给我了。

这不是08年的原题，但是单调栈的一个经典应用。注意，之所以说是单调栈，因为这个问题的状态就需要FILO的数据结构来维护；而另外一些问题，可能就需要FIFO。我看我之前做过，就奇怪08年现场赛没做出来。于是想重新写一遍。

结果写完了提交一直Wrong Answer。说白了就是状态没考虑清楚。我维护的栈是一个输入数据的下标。但这种状态设计就错了。看了好几份代码，没理解错哪。下午出门吃饭的时候用手机在github 上搜到一份[代码](https://gist.github.com/weidagang/5566372)。对着这份代码研究半天，终于明白了。光维护一个递增高度的下标是不够的，还需要高度最左能延伸到哪里。后来自己重写一遍，AC了。

我在自己代码判错之后，拿自己之前AC的代码做对比，结果觉得自己之前AC的代码好像还有逻辑问题；想明白之后，才发现实际上是自己的C代码把某个逻辑处理以更简单的方式实现了。但是真的很难以理解，我甚至怀疑我以前是不是蒙混过关了。我把之前的代码跟今天写的代码放一起([2013.cpp](https://github.com/liruqi/topcoder/blob/master/POJ/2559/2013.cpp), [2008.c](https://github.com/liruqi/topcoder/blob/master/POJ/2559/2008.c))，大家感受下。

尽可能地使用高级数据结构，如C++的vector, map, deque; 尽可能地使用结构化数据。理解比实现重要，代码可读性比代码长度重要。
